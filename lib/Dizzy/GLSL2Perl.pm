package Dizzy::GLSL2Perl;

use strict;
use warnings;

my $paren_group;
$paren_group = qr{\((?:(?>[^()]+)|(??{$paren_group}))*\)};

# directly transforms glsl to perl
# the resulting code depends on global variables ($gl_FragColor, @gl_TexCoord, ...)
sub _glsl2perl {
	my ($code) = @_;

	$_ = $code;

	# transform variables
	# assume variable when it is not followed by () for function calls.
	s/\b([a-zA-Z_]\w+)\b(?!\()/\$$1/g;

	# replace simple types with "my"
	# this won't work when there's an actual variable "float" in the program,
	# but anyone who does this is kinda insane anyway.
	s/\$(float|void)\b/my/g;

	# return is a keyword, not a variable
	s/\$(return)/$1/g;

	# subroutine definitions
	s/my (\w+)\s*\(([^\)]*)?\)\s*\{/"sub $1 \{ my (" . (length($2) ? do{ $_ = $2; s\/my \/\/g; $_ } : "undef") . ") = \@_;"/ge;

	# replace some function calls with new perly ones
	sub expand_function {
		my %fmap = (
			length => 'abs(_!_)',
			vec4 => 'vecx::vec4(_!_)',
			vec3 => 'vecx::vec3(_!_)',
			vec2 => 'vecx::vec2(_!_)',
			pow => 'sub{$_[0]**$_[1]}->(_!_)',
			atan => 'sub{atan2($_[1],$_[0])}->(_!_)',
		);
		$_ = $_[0];
		my ($fn, $args);
		s/\b(\w+)($paren_group)/$fmap{$1} ? (($args = $2), ($fn = $fmap{$1}), ($fn =~ s\/_!_\/expand_function($args)\/e), $fn) : "$1$2"/ge;
		return $_;
	}
	$_ = expand_function($_);

	# swizzling
	my %offsets = (
		r => 0, g => 1, b => 2, a => 3,
		x => 0, y => 1, z => 2, w => 3,
		s => 0, t => 1, p => 2, q => 3
	);
	s/($paren_group|\$\w+(?:\[\d+\])?)\.\$?([rgbaxyzwstpq]+)/(length($2) > 1 ? "vecx::vec" . length($2) : "") . "(\@{$1}[" . join(", ", map { $offsets{$_} } split(\/\/, $2)) . "])"/ge;

	return $_;
}

# generate an old-style coderef from glsl code
# the coderef is supposed to set up the global variables that code generated by
# the sub above needs
sub glsl2perl {
	my ($glsl) = @_;

	# first, convert the code itself
	my $core_code = _glsl2perl($glsl);

	# build wrapper code around it
	my $wrapper1 = << '		# END OF WRAPPER PART 1';
		package Dizzy::GLSL2Perl::RenderNS;
		no warnings 'redefine';
		use Math::Trig;
		my $gl_FragColor;
		my @gl_TexCoord;
		# END OF WRAPPER PART 1
	my $wrapper2 = << '		# END OF WRAPPER PART 2';
		sub {
			my ($x, $y) = @_;
			$gl_TexCoord[0] = vecx::vec4($x + 0.5, $y + 0.5);
			main();
			return $gl_FragColor->[0];
		}
		# END OF WRAPPER PART 2

	# build coderef
	my $coderef = eval($wrapper1 . $core_code . $wrapper2);

	if (!defined($coderef)) {
		print STDERR "*** GLSL2Perl: error in generated Perl: $@\n";
		print STDERR "Perl code:\n";
		print STDERR $wrapper1 . $core_code . $wrapper2 . "\n";
		die();
	}

	return $coderef;
}

1;

package vecx;

use Carp;
use List::Util qw(max sum);

use overload
	'neg' => \&V_negate,
	'+' => \&v_add,
	'-' => \&v_sub,
	'*' => \&v_mul,
	'/' => \&v_div,
	'abs' => \&v_abs,
;

# operations on vectors of the same size
sub V_negate {
	my ($v) = @_;
	return [ map { -$_ } @$v ];
}

sub V_add {
	my ($va, $vb) = @_;
	return [ map { $va->[$_] + $vb->[$_] } 0..$#$va ];
}

sub V_sub {
	my ($va, $vb) = @_;
	return V_add($va, V_negate($vb));
}

sub V_mul {
	my ($va, $vb) = @_;
	return [ map { $va->[$_] * $vb->[$_] } 0..$#$va ];
}

sub V_div {
	my ($va, $vb) = @_;
	return [ map { $va->[$_] / $vb->[$_] } 0..$#$va ];
}

sub V_length {
	my ($v) = @_;
	return sqrt(sum(map { $v->[$_] ** 2 } 0..$#$v));
}

# extend a vector to a 4-component one
sub V_extend4 {
	my ($v) = @_;
	if (ref($v) ne "") {
		return $v if (@$v == 4);
		return [(@$v) x 4] if (@$v == 1);
		return [(@$v, (1.0) x 3)[0..3]];
	} else {
		return [($v) x 4];
	}
}

# shrink a vector to the size of the larger of two reference vectors
# ex: shrinkab([0, 1, 2, 3], [a, b, c], [d]) = [0, 1, 2]
sub V_shrinkab {
	my ($v, $ra, $rb) = @_;
	$ra = [$ra] if (ref($ra) eq "");
	$rb = [$rb] if (ref($rb) eq "");
	return [@$v[0..max($#$ra, $#$rb)]];
}

# high level functions (for overload.pm)
sub v_add {
	my ($va, $vb) = @_;
	return bless(V_shrinkab(V_add(V_extend4($va), V_extend4($vb)), $va, $vb));
}

sub v_sub {
	my ($va, $vb) = @_;
	if (!defined($vb)) {
		return V_negate($va);
	} else {
		return bless(V_shrinkab(V_add(V_extend4($va), V_negate(V_extend4($vb))), $va, $vb));
	}
}

sub v_mul {
	my ($va, $vb) = @_;
	return bless(V_shrinkab(V_mul(V_extend4($va), V_extend4($vb)), $va, $vb));
}

sub v_div {
	my ($va, $vb) = @_;
	return bless(V_shrinkab(V_div(V_extend4($va), V_extend4($vb)), $va, $vb));
}

sub v_abs {
	my ($v) = @_;
	return V_length($v);
}

# helper functions (not overloaded)
sub v_merge {
	my @v;
	foreach (@_) {
		push(@v, @$_) if (ref($_) ne "");
		push(@v,  $_) if (ref($_) eq "");
	}
	return bless(\@v);
}

sub vec4 {
	return bless([@{V_extend4(v_merge(@_))}[0..3]]);
}

sub vec3 {
	return bless([@{V_extend4(v_merge(@_))}[0..2]]);
}

sub vec2 {
	return bless([@{V_extend4(v_merge(@_))}[0,1]]);
}

