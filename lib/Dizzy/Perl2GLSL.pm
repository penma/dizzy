package Dizzy::Perl2GLSL;

use strict;
use warnings;

use B;

sub walk_optree {
	my ($op, $cv) = @_;

	# gather op information
	my $optype = ref($op);
	$optype =~ s/^B:://;
	my $opname = $op->name;

	if ($optype eq "UNOP" or $optype eq "BINOP" or $optype eq "LISTOP") {
		my @list = $op->name;

		my $child = $op->first;
		while (ref($child) ne "B::NULL") {
			push(@list, walk_optree($child, $cv));

			# and go on with the next one
			$child = $child->sibling;
		}

		if ($op->name eq "null" or $op->name eq "leavesub") {
			return @list[1..$#list];
		} else {
			return [@list];
		}
	} elsif ($optype eq "SVOP") {
		my $sv = (($cv->PADLIST->ARRAY)[1]->ARRAY)[$op->targ];
		return ${$sv->object_2svref};
	} elsif ($optype eq "PADOP") {
		my $pad = (($cv->PADLIST->ARRAY)[1]->ARRAY)[$op->padix];
		return ["glob", $pad->NAME];
	} elsif ($optype eq "OP") {
		if ($op->name eq "padsv") {
			return "var" . $op->targ;
		} elsif ($op->name eq "pushmark") {
			return ();
		} else {
			return "# op description " . $op->desc;
		}
	} elsif ($optype eq "COP") {
		return ();
	}
}

# check if a trivial optimization can be applied
# if the op looks like it's been generated by code like
#     my $dist = sqrt($x**2 + $y**2);
# then return 1.
sub opt_check_dist_assignment {
	my ($op, $symtab) = @_;
	my @op = @{$op};

	return 0 if (ref($op[1]) eq "");                               # RHS is scalar
	return 0 if ($op[1]->[0] ne "sqrt");                           # not the sqrt function
	return 0 if (ref($op[1]->[1]) eq "");                          # scalar in sqrt

	my @arg = @{$op[1]->[1]};
	return 0 if ($arg[0] ne "add");                                # no addition
	return 0 if (ref($arg[1]) eq "" or ref($arg[2]) eq "");        # addition with a scalar
	return 0 if ($arg[1]->[0] ne "pow" or $arg[2]->[0] ne "pow");  # not adding two powers ($x**2 + $y**2)
	return 0 if ($arg[1]->[2] != 2 or $arg[2]->[2] != 2);          # not squaring the arguments

	if ($symtab->{$arg[1]->[1]} ne "coord_x"
	 or $symtab->{$arg[2]->[1]} ne "coord_y") {
		return 0;
	}

	# assume it is dist assignment
	return 1;
}

sub make_code {
	my ($op, $symtab) = @_;

	# not a ref? then it's a scalar
	if (ref($op) eq "") {
		# turn integers into floats..
		if ($op =~ /^\d+$/) {
			$op .= ".";
		}
		return $op;
	}

	# else it's a subexpression
	my @op = @{$op};
	if ($op[0] eq "lineseq") {
		# all child expressions are statements
		return join(";\n", map { make_code($_, $symtab) } @op[1..$#op]) . ";";
	} elsif ($op[0] eq "return") {
		# return a value: assign to the fragment color and return
		return "gl_FragColor = vec4(vec3(" . make_code($op[1], $symtab) . "), 1.0)";
	} elsif ($op[0] eq "entersub") {
		# external subroutine call: last child is the sub, rest is arguments
		return $op[$#op]->[1] . "(" . join(", ", map { make_code($_, $symtab) } @op[1..$#op-1]) . ")";
	} elsif ($op[0] eq "sassign") {
		# scalar assignment
		my $allocate = defined($symtab->{$op[2]}) ? "" : "float ";
		$symtab->{$op[2]} = 1;
		if (opt_check_dist_assignment($op, $symtab)) {
			return "$allocate$op[2] = length(gl_TexCoord[0].xy - 0.5)";
		} else {
			return "$allocate$op[2] = " . make_code($op[1], $symtab);
		}
	} elsif ($op[0] eq "aassign") {
		# list assignment
		# for now, only allow parameter assignment for this and reject everything else
		if ($op[1]->[0] ne "rv2av" or ref($op[1]->[1]) ne "ARRAY" or $op[1]->[1]->[0] ne "glob" or $op[1]->[1]->[1] ne "_") {
			return "ERROR";
		}
		$symtab->{$op[2]} = "coord_x";
		$symtab->{$op[3]} = "coord_y";
		return "float $op[2] = gl_TexCoord[0].x - 0.5; float $op[3] = gl_TexCoord[0].y - 0.5";

	} elsif ($op[0] =~ /^(add|subtract|multiply|divide)$/) {
		my $operator = { add => "+", subtract => "-", multiply => "*", divide => "/" }->{$op[0]};
		return "(" . make_code($op[1], $symtab) . " $operator " . make_code($op[2], $symtab) . ")";
	} elsif ($op[0] eq "negate") {
		return "-(" . make_code($op[1], $symtab) . ")";

	} elsif ($op[0] =~ /^(sqrt|sin|cos|pow|log)$/) {
		# builtin functions
		return "$op[0](" . join(", ", map { make_code($_, $symtab) } @op[1..$#op]) . ")";
	} else {
		return "UNKNOWN_$op[0]_OP";
	}
}

sub perl2glsl {
	my ($coderef) = @_;

	# generate an optree suitable for further processing
	my $cv = B::svref_2object($coderef);
	my $tree = walk_optree($cv->ROOT, $cv);

	# walk the optree, generating code out of it
	my $symtab = {};
	return "float wrapval(float val){return(val<0.0?1.0:(val>1.0?0.0:val));}float cosec(float val){return 1./sin(val);}" .
	"void main() { " . make_code($tree, $symtab) . "}\n";
}

1;
